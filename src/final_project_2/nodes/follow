#!/usr/bin/env python


import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from geometry_msgs.msg import PoseStamped, Twist
import tf
from fiducial_msgs.msg import FiducialTransformArray


rospy.set_param('goal_x', 0)
rospy.set_param('goal_y', 0)
rospy.set_param('goal_w', 1)


def publish_on_move_base():
    # Build message
    message.header.stamp = rospy.Time.now()
    message.pose.position.x = rospy.get_param('goal_x')
    message.pose.position.y = rospy.get_param('goal_y')
    message.pose.orientation.w = rospy.get_param('goal_w')

    # Publish message
    pub_goal.publish(message)

# def get_odom_data():
#     """Get the current pose of the robot from the /odom topic
#
#     Return
#     ----------
#     The position (x, y, z) and the yaw of the robot.
#     """
#     success = False
#     while not success:
#         try:
#             tf_listener.waitForTransform('follower_tf/odom', 'follower_tf/base_footprint', rospy.Time.now(), rospy.Duration(4.0))
#             (trans, rot) = tf_listener.lookupTransform('follower_tf/odom', 'follower_tf/base_footprint', rospy.Time.now())
#             # rotation is a list [r, p, y]
#             rotation = tf.transformations.euler_from_quaternion(rot)
#             success = True
#         except (tf.Exception, tf.ConnectivityException, tf.LookupException):
#             pass
#     # return the yaw
#     return rotation[2]


def handle_fiducial(msg):
    marker_data = msg.transforms
    global search
    global state

    if marker_data:  # found fiducial marker
        if state != 'following':
            rospy.loginfo("Following marker")
            state = 'following'

        # stop the robot first if have been searching
        if search[0]:
            rospy.loginfo("Marker found")
            search[0] = False  # mark as not searching
            search[2] = False  # mark as rotation not found
            velocity_msg.angular.z = 0  # stop rotation
            pub_cmd_vel.publish(velocity_msg)  # publish to follower/cmd_vel

        # marker_tf_cam = marker_data[0].transform
        # rospy.loginfo(marker_tf_cam)
        # trn = marker_tf_cam.translation
        # rot = marker_tf_cam.rotation


        # broadcast follower_tf/camera_rgb_optical_frame to tf transforms
        # br.sendTransform((trn.x, trn.y, 0),
        #                  (rot.x, rot.y, rot.z, rot.w),
        #                  rospy.Time.now(),
        #                  "follower_tf/camera_rgb_optical_frame",
        #                  "follower_tf/camera_link")
        #
        # try:  # often throws error for first time looking up, ignore this
        #     marker_tf = tf_listener.lookupTransform("follower_tf/camera_rgb_optical_frame", "map", rospy.Time.now())
        # except:
        #     return
        # (x, y, z) = marker_tf[0]
        # (roll, pitch, yaw) = tf.transformations.euler_from_quaternion(marker_tf[1])
        # pose = (x, y, yaw)
        # rospy.loginfo(marker_tf)

    else:  # marker not found
        # starting search, record initial angle
        if not search[0]:
            search[1] = 0  # save angle
            search[2] = False  # mark that full rotation not complete
            search[0] = True  # mark that in the process of searching

        # check if full rotation complete
        if search[1] > 360:
            if state != 'exploring':
                rospy.loginfo("Looking for marker: exploring")
                state = 'exploring'

            search[2] = True  # mark full rotation as complete
            velocity_msg.angular.z = 0  # stop rotation
            pub_cmd_vel.publish(velocity_msg)  # publish to follower/cmd_vel
            publish_on_move_base()
            rospy.Rate(0.5).sleep()

        # haven't completed a full rotation yet
        if not search[2]:
            if state != 'searching':
                rospy.loginfo("Looking for marker: rotating")
                state = 'searching'

            velocity_msg.angular.z = 2
            search[1] += 5.2  # ~# of degrees per 0.35 seconds at angular vel 0f 2
            pub_cmd_vel.publish(velocity_msg)
            rospy.Rate(0.1)

    rospy.Rate(0.25)


if __name__ == '__main__':
    rospy.init_node('follow_leader')

    # setup tf stuff
    tf_listener = tf.TransformListener()
    br = tf.TransformBroadcaster()

    # setup searching stuff
    pub_cmd_vel = rospy.Publisher("/follower/cmd_vel", Twist, queue_size=5)
    velocity_msg = Twist()

    # setup move to goal stuff
    pub_goal = rospy.Publisher("/follower/move_base_simple/goal", PoseStamped, queue_size=10)
    message = PoseStamped()
    message.header.frame_id = "map"
    message.pose.position.z = 0

    # setup state tracking
    search = [False, 0, False]  # [bool of if searching, odom angle started searching at, bool of if loop completed]
    state = None  # stores the state follower robot to limit loginfo

    # start main
    rospy.Subscriber("fiducial_transforms", FiducialTransformArray, handle_fiducial)
    rospy.spin()

